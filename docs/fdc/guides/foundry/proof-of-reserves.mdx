---
title: Proof of Reserves
slug: proof-of-reserves
authors: [anthonyamadia]
description: A cross-chain Proof of Reserves dApp using the EVMTransaction and Web2Json attestation types.
tags: [fdc, foundry]
keywords:
  [
    ethereum,
    flare-data-connector,
    evm,
    cross-chain,
    proof-of-reserves,
    web2json,
  ]
sidebar_position: 12
---

import AvailableTestnet from "../_available_testnet.mdx";

This guide demonstrates how to build a simple Proof of Reserves dApp using the Flare Data Connector (FDC). It showcases how multiple attestation types, namely `EVMTransaction` and `Web2Json`, can be combined within the same application to solve a real-world problem.

The application enables on-chain verification that a stablecoin's circulating supply across multiple blockchains is backed by sufficient off-chain reserves. We will first describe the problem the app is addressing and then provide a detailed walkthrough of its implementation using Foundry.

<AvailableTestnet />

### The Problem

Stablecoins are cryptographic tokens designed to maintain a fixed value, typically pegged to a fiat currency like the US dollar. To maintain trust, the issuing institution must hold sufficient reserves to back all tokens in circulation.

The `ProofOfReserves` application demonstrates how to verify that a stablecoin issuer maintains adequate off-chain dollar reserves to cover all of its tokens across multiple blockchains. This verification creates transparency and helps prevent situations where more tokens exist than the backing reserves can support.

Implementing this verification system presents three technical challenges:

1.  **Accessing Off-Chain Data**: We need to query a Web2 API that reports the institution's official dollar reserves.
2.  **Reading On-Chain State**: We need to access the total token supply data from various blockchain networks where the token is deployed.
3.  **Cross-Chain Data Aggregation**: We need to aggregate token supply information from multiple chains and compare it to the off-chain reserve data.

The Flare Data Connector (FDC) provides solutions for accessing Web2 APIs through the `Web2Json` attestation type and collecting cross-chain data via the `EVMTransaction` attestation type. For reading on-chain state, we deploy a dedicated contract that reads the token supply and emits this data as an event, which can then be attested to.

### Smart Contract Architecture

For our Proof of Reserves implementation, we'll create three distinct smart contracts:

1.  **`MyStablecoin`**: A custom ERC20 token for testing purposes.
2.  **`TokenStateReader`**: A utility contract that reads and broadcasts the token's total supply data via an event.
3.  **`ProofOfReserves`**: The main verification contract that processes attestation proofs.

#### Stablecoin Contract

This contract creates a standard ERC20-compatible token with controlled minting, allowing us to simulate a stablecoin for this example.

```solidity title="src/proofOfReserves/Token.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract MyStablecoin is ERC20, ERC20Burnable, Ownable {
    constructor(address recipient, address initialOwner)
        ERC20("MyStablecoin", "MST")
        Ownable(initialOwner)
    {
        _mint(recipient, 666 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
```

#### TokenStateReader Contract

The FDC's `EVMTransaction` attestation type works by verifying data from events. To get the `totalSupply` of our token on-chain, we deploy this simple contract. Its only function is to read the `totalSupply` of a given ERC20 token and emit it in an event, making the state readable by the FDC.

```solidity title="src/proofOfReserves/TokenStateReader.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TokenStateReader {
    event TotalTokenSupply(address tokenAddress, uint256 totalSupply);

    function broadcastTokenSupply(ERC20 token) external returns (uint256) {
        uint256 supply = token.totalSupply();
        emit TotalTokenSupply(address(token), supply);
        return supply;
    }
}
```

#### ProofOfReserves Contract

This is the core contract that performs the final verification. It takes the attested off-chain reserve data and the attested on-chain supply data from multiple chains, aggregates them, and determines if the reserves are sufficient.

```solidity title="src/proofOfReserves/ProofOfReserves.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {IWeb2Json} from "flare-periphery/src/coston2/IWeb2Json.sol";
import {IEVMTransaction} from "flare-periphery/src/coston2/IEVMTransaction.sol";
import {ContractRegistry} from "flare-periphery/src/coston2/ContractRegistry.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

// ... helper structs and events

contract ProofOfReserves is Ownable {
    // ... state variables and events

    mapping(address => address) public tokenStateReaders;

    constructor() Ownable(msg.sender) {}

    function updateAddress(address readerAddress, address tokenAddress) public onlyOwner {
        tokenStateReaders[readerAddress] = tokenAddress;
    }

    function verifyReserves(
        IWeb2Json.Proof calldata jsonProof,
        IEVMTransaction.Proof[] calldata transactionProofs
    ) external returns (bool) {
        uint256 claimedReserves = readReserves(jsonProof);

        uint256 totalTokenSupply = 0;
        for (uint256 i = 0; i < transactionProofs.length; i++) {
            totalTokenSupply += readTokenSupply(transactionProofs[i]);
        }

        return totalTokenSupply <= (claimedReserves * 1 ether);
    }

    function readReserves(IWeb2Json.Proof calldata proof) private view returns (uint256) {
        require(isValidProof(proof), "Invalid json proof");
        // Decode the reserve amount from the proof
        DataTransportObject memory data = abi.decode(
            proof.data.responseBody.abi_encoded_data,
            (DataTransportObject)
        );
        return data.reserves;
    }

    function readTokenSupply(IEVMTransaction.Proof calldata proof) private view returns (uint256) {
        require(isValidProof(proof), "Invalid transaction proof");
        uint256 totalSupply = 0;
        // Loop through all events in the transaction proof
        for (uint256 i = 0; i < proof.data.responseBody.events.length; i++) {
            IEVMTransaction.Event memory _event = proof.data.responseBody.events[i];
            address readerAddress = _event.emitterAddress;
            (address tokenAddress, uint256 supply) = abi.decode(_event.data, (address, uint256));

            // Ensure the event came from a registered reader for the correct token
            if (tokenStateReaders[readerAddress] == tokenAddress) {
                totalSupply += supply;
            }
        }
        return totalSupply;
    }

    function isValidProof(IWeb2Json.Proof calldata proof) private view returns (bool) {
        return ContractRegistry.getFdcVerification().verifyWeb2Json(proof);
    }

    function isValidProof(IEVMTransaction.Proof calldata proof) private view returns (bool) {
        return ContractRegistry.getFdcVerification().verifyEVMTransaction(proof);
    }
}
```

### Process Overview

This guide demonstrates deployment on Flare's Coston and Coston2 testnets, but the same approach can be adapted for any EVM chains. The complete process is broken down into sequential scripts:

1.  **`Deploy`**: Deploys `MyStablecoin` and `TokenStateReader` to both Coston and Coston2, and `ProofOfReserves` to Coston2 only.
2.  **`ActivateReaders`**: Calls `broadcastTokenSupply` on both chains to create transactions whose events can be attested to.
3.  **`PrepareRequests`**: Constructs the off-chain FDC requests for both the Web2 reserve data and the on-chain transaction data.
4.  **`SubmitRequests`**: Submits the prepared requests to the FDC on Coston.
5.  **`RetrieveProofs`**: Waits for finalization and fetches the proofs from the Data Availability Layer.
6.  **`VerifyReserves`**: Delivers the proofs to the `ProofOfReserves` contract for final verification.

### Step 1: Deploy Contracts

The `Deploy` script handles the initial setup, deploying all necessary contracts to their respective chains and saving their addresses to configuration files for later scripts to use.

```solidity title="script/ProofOfReserves.s.sol"
contract Deploy is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address owner = vm.addr(deployerPrivateKey);
        uint256 chainId = block.chainid;

        vm.createDir(dirPath, true);
        vm.startBroadcast(deployerPrivateKey);

        // Deploy contracts
        MyStablecoin token = new MyStablecoin(owner, owner);
        TokenStateReader reader = new TokenStateReader();

        // Write addresses to chain-specific files
        string memory tokenPath = string.concat(dirPath, "_token_", Strings.toString(chainId), ".txt");
        string memory readerPath = string.concat(dirPath, "_reader_", Strings.toString(chainId), ".txt");
        vm.writeFile(tokenPath, vm.toString(address(token)));
        vm.writeFile(readerPath, vm.toString(address(reader)));

        // Deploy the main contract only to Coston2
        if (chainId == 114) { // Coston2
            ProofOfReserves proofOfReserves = new ProofOfReserves();
            string memory porPath = string.concat(dirPath, "_proofOfReserves_", Strings.toString(chainId), ".txt");
            vm.writeFile(porPath, vm.toString(address(proofOfReserves)));
            console.log("ProofOfReserves deployed to:", address(proofOfReserves));
        }

        vm.stopBroadcast();
        console.log("--- Deployment Results for Chain ID:", chainId, "---");
        console.log("MyStablecoin deployed to:", address(token));
        console.log("TokenStateReader deployed to:", address(reader));
    }
}
```

Run this script on both Coston and Coston2:

```bash
forge script script/ProofOfReserves.s.sol:Deploy --rpc-url $COSTON_RPC_URL --broadcast
forge script script/ProofOfReserves.s.sol:Deploy --rpc-url $COSTON2_RPC_URL --broadcast
```

### Step 2: Activate State Readers

The `ActivateReaders` script calls the `broadcastTokenSupply` function on the `TokenStateReader` contracts on both chains. This creates a transaction with a `TotalTokenSupply` event. The script then reads the transaction hash from the Foundry broadcast receipt and saves it to a file. This hash is the input for the `EVMTransaction` attestation.

```solidity title="script/ProofOfReserves.s.sol"
contract ActivateReaders is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        uint256 chainId = block.chainid;

        address tokenAddress = vm.parseAddress(vm.readFile(string.concat(dirPath, "_token_", Strings.toString(chainId), ".txt")));
        address readerAddress = vm.parseAddress(vm.readFile(string.concat(dirPath, "_reader_", Strings.toString(chainId), ".txt")));

        TokenStateReader reader = TokenStateReader(readerAddress);
        MyStablecoin token = MyStablecoin(tokenAddress);

        vm.startBroadcast(deployerPrivateKey);
        reader.broadcastTokenSupply(token);
        vm.stopBroadcast();

        // Read the transaction hash from the broadcast receipt
        string memory receiptPath = string(abi.encodePacked("broadcast/ProofOfReserves.s.sol/", vm.toString(chainId), "/run-latest.json"));
        string memory receiptJson = vm.readFile(receiptPath);
        string memory txHash = receiptJson.readString(".transactions[0].transactionHash");

        string memory txHashPath = string.concat(dirPath, "_txHash_", Strings.toString(chainId), ".txt");
        vm.writeFile(txHashPath, txHash);

        console.log("Reader activated on chain:", chainId, "with txHash:", txHash);
    }
}
```

Run this script on both chains to generate the necessary on-chain events:

```bash
forge script script/ProofOfReserves.s.sol:ActivateReaders --rpc-url $COSTON_RPC_URL --broadcast
forge script script/ProofOfReserves.s.sol:ActivateReaders --rpc-url $COSTON2_RPC_URL --broadcast
```

### Step 3: Prepare Attestation Requests

This script reads the transaction hashes from the files and prepares all the necessary FDC requests. This is an off-chain step that uses `--ffi` to call the verifier APIs and construct the ABI-encoded request bytes.

```solidity title="script/ProofOfReserves.s.sol"
contract PrepareRequests is Script {
    function run() external {
        string memory txHashCoston = vm.readFile(string.concat(dirPath, "_txHash_16.txt"));
        string memory txHashCoston2 = vm.readFile(string.concat(dirPath, "_txHash_114.txt"));

        // Prepare Web2 reserve data request
        bytes memory web2JsonRequest = prepareWeb2JsonRequest();
        FdcBase.writeToFile(dirPath, "_Web2Json_request.txt", StringsBase.toHexString(web2JsonRequest), true);

        // Prepare EVM transaction data requests for both chains
        bytes memory evmCostonRequest = prepareEvmTransactionRequest("testSGB", "sgb", txHashCoston);
        FdcBase.writeToFile(dirPath, "_EVMTransaction_Coston_request.txt", StringsBase.toHexString(evmCostonRequest), true);

        bytes memory evmCoston2Request = prepareEvmTransactionRequest("testFLR", "flr", txHashCoston2);
        FdcBase.writeToFile(dirPath, "_EVMTransaction_Coston2_request.txt", StringsBase.toHexString(evmCoston2Request), true);
    }

    // ... helper functions to call verifier APIs ...
}
```

Run the script to prepare all requests:

```bash
forge script script/ProofOfReserves.s.sol:PrepareRequests --rpc-url $COSTON_RPC_URL --ffi
```

### Step 4: Submit Requests to FDC

This script reads the prepared request bytes from the files and submits them to the `FdcHub` contract, initiating the attestation process for each piece of data. The `votingRoundId` for each request is saved for proof retrieval.

```solidity title="script/ProofOfReserves.s.sol"
contract SubmitRequests is Script {
    function run() external {
        _submitRequest("_Web2Json");
        _submitRequest("_EVMTransaction_Coston");
        _submitRequest("_EVMTransaction_Coston2");
    }

    function _submitRequest(string memory attestationType) private {
        // ... reads request file, submits, and writes roundId file ...
    }
}
```

Run the script to submit all requests to the FDC:

```bash
forge script script/ProofOfReserves.s.sol:SubmitRequests --rpc-url $COSTON_RPC_URL --broadcast
```

### Step 5: Retrieve Proofs

After waiting for the voting rounds to finalize (typically 90-180 seconds), this script queries the Data Availability layer for the attestation proofs for all three requests and saves them to files.

```solidity title="script/ProofOfReserves.s.sol"
contract RetrieveProofs is Script {
    function run() external {
        // ... retrieves and saves Web2Json proof ...
        // ... retrieves and saves Coston EVM proof ...
        // ... retrieves and saves Coston2 EVM proof ...
    }

    // ... helper functions to parse proof data ...
}
```

Run the script to fetch the finalized proofs:

```bash
forge script script/ProofOfReserves.s.sol:RetrieveProofs --rpc-url $COSTON_RPC_URL --ffi
```

### Step 6: Verify Reserves

This final script reads the three saved proofs from their files, updates the `ProofOfReserves` contract with the correct reader-to-token mappings, and calls the `verifyReserves` function with all the proofs. The contract performs the on-chain verification, and the script logs the final result.

```solidity title="script/ProofOfReserves.s.sol"
contract VerifyReserves is Script {
    function run() external {
        IWeb2Json.Proof memory web2Proof = abi.decode(/* ... */);
        IEVMTransaction.Proof memory evmCostonProof = abi.decode(/* ... */);
        IEVMTransaction.Proof memory evmCoston2Proof = abi.decode(/* ... */);

        address proofOfReservesAddress = vm.parseAddress(/* ... */);
        // ... read other addresses

        ProofOfReserves por = ProofOfReserves(payable(proofOfReservesAddress));

        IEVMTransaction.Proof[] memory evmProofs = new IEVMTransaction.Proof[](2);
        evmProofs[0] = evmCostonProof;
        evmProofs[1] = evmCoston2Proof;

        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        por.updateAddress(readerCostonAddress, tokenCostonAddress);
        por.updateAddress(readerCoston2Address, tokenCoston2Address);
        bool success = por.verifyReserves(web2Proof, evmProofs);
        vm.stopBroadcast();

        console.log("\n--- VERIFICATION COMPLETE ---");
        console.log("Sufficient Reserves Check Passed:", success);
    }
}
```

Run the script to execute the final verification:

```bash
forge script script/ProofOfReserves.s.sol:VerifyReserves --rpc-url $COSTON_RPC_URL --broadcast
```
